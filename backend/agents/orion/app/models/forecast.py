"""
Forecast Model

Stores demand forecasts generated by ML models
"""
from sqlalchemy import Column, String, DateTime, Decimal, Date, Index, UniqueConstraint
from sqlalchemy.dialects.postgresql import UUID, JSONB
from datetime import datetime
import uuid
from .database import Base


class Forecast(Base):
    """
    Demand forecast records

    Stores predictions for future product demand.
    Each record represents a forecast for a specific product on a specific date.
    """
    __tablename__ = "forecasts"

    # Primary key
    id = Column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
        server_default="gen_random_uuid()"
    )

    # Target
    product_id = Column(UUID(as_uuid=True), nullable=False, index=True)
    sku = Column(String(100), nullable=False)

    # Forecast period
    forecast_date = Column(Date, nullable=False, index=True)
    forecast_horizon = Column(String(20), nullable=True)  # e.g., "7-day", "30-day"

    # Predictions
    predicted_quantity = Column(Decimal(10, 2), nullable=False)
    confidence_interval_lower = Column(Decimal(10, 2), nullable=True)
    confidence_interval_upper = Column(Decimal(10, 2), nullable=True)
    confidence_score = Column(Decimal(3, 2), nullable=True)  # 0.00 to 1.00

    # Model information
    model_name = Column(String(100), nullable=True)  # e.g., "SARIMA", "Prophet", "Ensemble"
    model_version = Column(String(50), nullable=True)  # e.g., "1.0", "2.1"
    features_used = Column(JSONB, nullable=True)  # JSON of features used in prediction

    # Actual values (for evaluation after the fact)
    actual_quantity = Column(Decimal(10, 2), nullable=True)
    error = Column(Decimal(10, 2), nullable=True)  # Prediction error

    # Metadata
    generated_at = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)

    # Constraints and indexes
    __table_args__ = (
        UniqueConstraint("product_id", "forecast_date", "forecast_horizon", name="uq_forecast_product_date_horizon"),
        Index("idx_forecast_date_desc", forecast_date.desc()),
        Index("idx_forecast_generated_desc", generated_at.desc()),
        Index("idx_forecast_product_date", product_id, forecast_date),
    )

    def __repr__(self):
        return (
            f"<Forecast(id={self.id}, "
            f"product_id={self.product_id}, "
            f"forecast_date={self.forecast_date}, "
            f"predicted={self.predicted_quantity})>"
        )

    def to_dict(self):
        """Convert to dictionary"""
        return {
            "id": str(self.id),
            "product_id": str(self.product_id),
            "sku": self.sku,
            "forecast_date": self.forecast_date.isoformat() if self.forecast_date else None,
            "forecast_horizon": self.forecast_horizon,
            "predicted_quantity": float(self.predicted_quantity) if self.predicted_quantity else None,
            "confidence_interval_lower": float(self.confidence_interval_lower) if self.confidence_interval_lower else None,
            "confidence_interval_upper": float(self.confidence_interval_upper) if self.confidence_interval_upper else None,
            "confidence_score": float(self.confidence_score) if self.confidence_score else None,
            "model_name": self.model_name,
            "model_version": self.model_version,
            "features_used": self.features_used,
            "actual_quantity": float(self.actual_quantity) if self.actual_quantity else None,
            "error": float(self.error) if self.error else None,
            "generated_at": self.generated_at.isoformat() if self.generated_at else None,
            "created_at": self.created_at.isoformat() if self.created_at else None,
        }

    def calculate_error(self):
        """
        Calculate prediction error if actual quantity is available

        Returns:
            Absolute error or None if actual not available
        """
        if self.actual_quantity is not None and self.predicted_quantity is not None:
            self.error = abs(self.predicted_quantity - self.actual_quantity)
            return self.error
        return None

    def get_mape(self) -> float:
        """
        Calculate Mean Absolute Percentage Error

        Returns:
            MAPE as percentage or None
        """
        if self.actual_quantity and self.actual_quantity != 0 and self.error:
            return float((self.error / self.actual_quantity) * 100)
        return None
